3.csv.DictReader
4.ValueError
5.JSON string
6.else
7.KeyError
8.Error
9."w"
10.a:10
11.finally
12.none
13.FileNotFoundError
14.key-value
15.Tuple
16.raise
17.indexing
18.json.dump
19.program terminates
20.specific except blocks

     -------DESCRIPTIVE--------


21.JSON: JSON refers to JavaScript Object Notation. It is a language-independent, human-      readable language used for its simplicity and is most commonly used in web-based   applications. The JSON extensions end with a .json. JSON is a user-friendly substitute for XML as it is lightweight and easy to read. It supports data structures like array and objects and the JSON documents that are rapidly executed on the server.

CSV: CSV refers to Comma-Separated Values. It holds plain text as a series of values (cells) separated by commas (, ) in a series of lines (rows). CSV file can actually open in a text editor and read it. There are lots of applications for reading CSV files, and many languages provide built-in functions that simplify reading/writing CSV format. These files are majority used by professionals in data analysis or visualizations.


22. Exception handling is the mechanism in Python (and most programming languages) that lets you detect and respond to runtime errors gracefully instead of letting the program crash.


Why it is mandatory in file-based programs:
File operations are inherently risky because they depend on external resources (the filesystem, permissions, hardware). Many things can go wrong that are outside your programâ€™s control. Without exception handling, your program would crash immediately when such an error occurs.

23. - try â†’ Contains code that may raise an exception.
    - except â†’ Handles the exception if one occurs in the try block.
    - else â†’ Runs only if no exception occurs in the try block.
    - finally â†’ Always runs, whether an exception occurred or not (commonly used for cleanup tasks like closing files).

ðŸ”¹ Execution Flow
Case 1: No Exception
try:
    print("No error here")
except ValueError:
    print("Error handled")
else:
    print("Else runs because no exception")
finally:
    print("Finally always runs")


Output:
No error here
Else runs because no exception
Finally always runs



Case 2: Exception Occurs
try:
    print(10 / 0)   # Raises ZeroDivisionError
except ZeroDivisionError:
    print("Error handled")
else:
    print("Else skipped because exception occurred")
finally:
    print("Finally always runs")


Output:
Error handled
Finally always runs



24.  A set in Python is an unordered collection of unique elements. Unlike lists or tuples, sets automatically remove duplicates and are optimized for membership tests and mathematical operations like union, intersection, and difference.


   âœ… Real-World Use Cases of Sets
   1.removing duplicates

    emails = ["a@gmail.com", "b@gmail.com", "a@gmail.com"]
unique_emails = set(emails)
print(unique_emails)  # {'a@gmail.com', 'b@gmail.com'}

   2.membership testing

    registered_users = {"alice", "bob", "charlie"}
print("david" in registered_users)  


3.set operations in analytics

    course_A = {"alice", "bob", "david"}
course_B = {"bob", "charlie"}
print(course_A & course_B)  # {'bob'} â†’ intersection


 4.tagging and categorization

   
    tags = {"python", "coding", "tutorial", "python"}  
print(tags)  # {'python', 'coding', 'tutorial'}


25.  Generic exception handling (using a broad except Exception: or just except:) should be used carefully because while it prevents your program from crashing, it can also hide important problems and make debugging harder.

     ðŸ”¹ Why it can be risky
1. Masks specific errors:
- You wonâ€™t know whether the error was a FileNotFoundError, ValueError, or something more serious.
- This makes troubleshooting difficult.
2. Can hide programming mistakes
- Bugs like typos, logic errors, or unexpected exceptions may get silently swallowed, leading to incorrect results instead of clear error messages.
3. May catch system-level exceptions
- Broad handling can unintentionally catch exceptions like KeyboardInterrupt or SystemExit, preventing the program from stopping when it should.
4.Reduces clarity
- Code becomes less predictable because you donâ€™t know which errors are being handled and which are ignored.



-------PROGRAMS-------

26.
# Dictionary storing student marks
student_marks = {
    "Alice": 85,
    "Bob": 78,
    "Charlie": 92,
    "David": 67
}

# Accept student name as input
name = input("Enter student name: ")

try:
    # Try to access marks
    marks = student_marks[name]
    print(f"{name}'s marks: {marks}")
except KeyError:
    # Handle missing student
    print("Error: Student not found in records.")

 27.
# Program: Set operations on two sets of integers

# Accept two sets of integers from the user
set1 = set(map(int, input("Enter integers for Set 1 (space-separated): ").split()))
set2 = set(map(int, input("Enter integers for Set 2 (space-separated): ").split()))

# Display results
print("Set 1:", set1)
print("Set 2:", set2)

# Union
print("Union:", set1 | set2)

# Intersection
print("Intersection:", set1 & set2)

# Difference (Set1 - Set2)
print("Difference (Set1 - Set2):", set1 - set2)

# Difference (Set2 - Set1)
print("Difference (Set2 - Set1):", set2 - set1)



28.
# Program: Read a file and count lines with exception handling

try:
    # Try to open and read the file
    with open("data.txt", "r", encoding="utf-8") as f:
        lines = f.readlines()
        print("Number of lines in file:", len(lines))

except FileNotFoundError:
    # Handle missing file safely
    print("Error: The file 'data.txt' was not found.")

except PermissionError:
    # Handle permission issues
    print("Error: You don't have permission to read 'data.txt'.")

finally:
    # Always runs, useful for cleanup or logging
    print("File handling operation completed.")


  29.
    import json

# Step 1: Create a dictionary with book details
book_details = {
    "title": "Python Programming",
    "author": "John Doe",
    "year": 2024,
    "price": 499,
    "publisher": "TechBooks"
}

# Step 2: Save dictionary into a JSON file
try:
    with open("books.json", "w", encoding="utf-8") as f:
        json.dump(book_details, f, indent=4)
    print("Book details saved successfully to books.json")
except Exception as e:
    print("Error while saving JSON:", e)

# Step 3: Read back from JSON file
try:
    with open("books.json", "r", encoding="utf-8") as f:
        data = json.load(f)
    print("\nBook details read from file:")
    for key, value in data.items():
        print(f"{key}: {value}")
except FileNotFoundError:
    print("Error: books.json file not found.")
except json.JSONDecodeError:
    print("Error: Invalid JSON format in file.")



 30.
  1.data['c'] â†’ KeyError because key 'c' does not exist in the dictionary.
  2. File is opened without specifying mode (better to use 'r' explicitly).
  3.File is not closed after reading (good practice to use with statement).
  4.If info.txt does not exist, it will raise FileNotFoundError.


    data = {'a': 1, 'b': 2}

# Safely accessing dictionary key
print(data.get('c', "Key not found"))

# Safely reading file
try:
    with open('info.txt', 'r') as file:
        print(file.read())
except FileNotFoundError:
    print("File not found.")
























